From 966d586048f132bfe75ae08fef594371b49ac510 Mon Sep 17 00:00:00 2001
From: Pavel Nakonechnyi <pavel@gremwell.com>
Date: Sun, 7 Jul 2019 10:16:51 +0200
Subject: [PATCH 1/6] pico-imx8mq: perform FEC and its PHY configuration more
 accurately

---
 arch/arm/include/asm/mach-imx/iomux-v3.h   |  15 +++
 board/technexion/pico-imx8mq/pico-imx8mq.c | 116 +++++++++++++++------
 2 files changed, 99 insertions(+), 32 deletions(-)

diff --git a/arch/arm/include/asm/mach-imx/iomux-v3.h b/arch/arm/include/asm/mach-imx/iomux-v3.h
index 34f2af4838..047ba76a73 100644
--- a/arch/arm/include/asm/mach-imx/iomux-v3.h
+++ b/arch/arm/include/asm/mach-imx/iomux-v3.h
@@ -292,4 +292,19 @@ if (is_mx6dq() || is_mx6dqp()) {				\
 	imx_iomux_v3_setup_multiple_pads(x, ARRAY_SIZE(x))
 #endif
 
+#if defined(CONFIG_MX6QDL)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX6Q_PAD_##name, ctrl), \
+		NEW_PAD_CTRL(MX6DL_PAD_##name, ctrl)
+#elif defined(CONFIG_MX7D)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX7D_PAD_##name, ctrl)
+#elif defined(CONFIG_MX51)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX51_PAD_##name, ctrl)
+#elif defined(CONFIG_MX53)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX53_PAD_##name, ctrl)
+#elif defined(CONFIG_IMX8M)
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(IMX8MQ_PAD_##name, ctrl)
+#else
+#define IOMUX_PAD_CTRL(name, ctrl)	NEW_PAD_CTRL(MX6_PAD_##name, ctrl)
+#endif
+
 #endif	/* __MACH_IOMUX_V3_H__*/
diff --git a/board/technexion/pico-imx8mq/pico-imx8mq.c b/board/technexion/pico-imx8mq/pico-imx8mq.c
index 6fea453fd9..e58b1c3c3e 100644
--- a/board/technexion/pico-imx8mq/pico-imx8mq.c
+++ b/board/technexion/pico-imx8mq/pico-imx8mq.c
@@ -44,19 +44,6 @@ static iomux_v3_cfg_t const uart_pads[] = {
 	IMX8MQ_PAD_UART1_TXD__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
 };
 
-int board_early_init_f(void)
-{
-	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
-
-	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
-
-	set_wdog_reset(wdog);
-
-	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
-
-	return 0;
-}
-
 #ifdef CONFIG_BOARD_POSTCLK_INIT
 int board_postclk_init(void)
 {
@@ -122,15 +109,18 @@ int ft_board_setup(void *blob, bd_t *bd)
 }
 #endif
 
+#define WEAK_PULLUP		(PAD_CTL_DSE6 | PAD_CTL_HYS | PAD_CTL_PUE)
+#define WEAK_PULLUP_OUTPUT	0xd1
+#define WEAK_PULLDN_OUTPUT	0x91	/* Cannot pull down */
+
 #ifdef CONFIG_FEC_MXC
 #define FEC_RST_PAD IMX_GPIO_NR(1, 9)
 static iomux_v3_cfg_t const fec1_rst_pads[] = {
-	IMX8MQ_PAD_GPIO1_IO09__GPIO1_IO9 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	IMX8MQ_PAD_GPIO1_IO09__GPIO1_IO9 | MUX_PAD_CTRL(WEAK_PULLUP),
 };
-
-#define FEC_PWR_PAD IMX_GPIO_NR(1, 0)
-static iomux_v3_cfg_t const fec1_pwr_pads[] = {
-	IMX8MQ_PAD_GPIO1_IO00__GPIO1_IO0 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define FEC_IRQ_PAD IMX_GPIO_NR(1, 2)
+static iomux_v3_cfg_t const fec1_irq_pads[] = {
+	IMX8MQ_PAD_GPIO1_IO11__GPIO1_IO11 | MUX_PAD_CTRL(WEAK_PULLUP),
 };
 
 #define WL_REG_ON_PAD IMX_GPIO_NR(3, 24)
@@ -143,43 +133,88 @@ static iomux_v3_cfg_t const bt_on_pads[] = {
 	IMX8MQ_PAD_SAI5_RXD0__GPIO3_IO21 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+#define PAD_CTRL_ENET_RX	0x91
+
+static const iomux_v3_cfg_t enet_ar8035_pads[] = {
+	IOMUX_PAD_CTRL(ENET_RD0__ENET_RGMII_RD0, PAD_CTRL_ENET_RX),
+	IOMUX_PAD_CTRL(ENET_RD1__ENET_RGMII_RD1, PAD_CTRL_ENET_RX),
+	IOMUX_PAD_CTRL(ENET_RD2__ENET_RGMII_RD2, PAD_CTRL_ENET_RX),
+	IOMUX_PAD_CTRL(ENET_RD3__ENET_RGMII_RD3, PAD_CTRL_ENET_RX),
+	IOMUX_PAD_CTRL(ENET_RX_CTL__ENET_RGMII_RX_CTL, PAD_CTRL_ENET_RX),
+	IOMUX_PAD_CTRL(ENET_RXC__ENET_RGMII_RXC, PAD_CTRL_ENET_RX),
+};
+
 static void setup_iomux_fec(void)
 {
 	imx_iomux_v3_setup_multiple_pads(fec1_rst_pads, ARRAY_SIZE(fec1_rst_pads));
-	imx_iomux_v3_setup_multiple_pads(fec1_pwr_pads, ARRAY_SIZE(fec1_pwr_pads));
-
-	gpio_request(IMX_GPIO_NR(1, 0), "fec1_pwr");
-	gpio_direction_output(IMX_GPIO_NR(1, 0), 1);
-	udelay(500);
+	imx_iomux_v3_setup_multiple_pads(fec1_irq_pads, ARRAY_SIZE(fec1_irq_pads));
 
-	gpio_request(IMX_GPIO_NR(1, 9), "fec1_rst");
-	gpio_direction_output(IMX_GPIO_NR(1, 9), 0);
-	udelay(500);
-	gpio_direction_output(IMX_GPIO_NR(1, 9), 1);
+	gpio_request(IMX_GPIO_NR(1, 2), "fec1_irq");
+	gpio_direction_input(IMX_GPIO_NR(1, 2));
 }
 
-static int setup_fec(void)
+static void init_fec_clocks(void)
 {
 	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
 		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
 
-	setup_iomux_fec();
-
 	/* Use 125M anatop REF_CLK1 for ENET1, not from external */
 	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
-			IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_SHIFT, 0);
-	return set_clk_enet(ENET_125MHZ);
+			BIT(13) | BIT(17), 0);
+	set_clk_enet(ENET_125MHZ);
+	udelay(100);	/* Wait 100 us before using mii interface */
+}
+
+static int setup_fec(void)
+{
+	gpio_request(IMX_GPIO_NR(1, 9), "fec1_rst");
+
+	gpio_direction_output(IMX_GPIO_NR(1, 9), 1);
+	udelay(1000 * 10);
+	gpio_direction_output(IMX_GPIO_NR(1, 9), 0);
+
+	init_fec_clocks();
+
+	/* 1 ms minimum reset pulse for ar8035 */
+	udelay(1000 * 10);
+	gpio_direction_output(IMX_GPIO_NR(1, 9), 1);
+
+	/* strap hold time for AR8031, 18 fails, 19 works, so 40 should be safe */
+	/* strap hold time for AR8035, 5 fails, 6 works, so 12 should be safe */
+	udelay(40);
+
+	imx_iomux_v3_setup_multiple_pads(enet_ar8035_pads, ARRAY_SIZE(enet_ar8035_pads));
+
+	return 0;
 }
 
 
 int board_phy_config(struct phy_device *phydev)
 {
+	int val;
+
+	/*
+	 * Ar803x phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x3);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x805d);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4003);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val & ~(1 << 8));
+
 	/* enable rgmii rxc skew and phy mode select to RGMII copper */
+	/*
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
 
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+	*/
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, (val|0x0100));
 
 	if (phydev->drv->config)
 		phydev->drv->config(phydev);
@@ -282,6 +317,23 @@ void setup_wifi(void)
 	gpio_set_value(BT_ON_PAD, 0);
 }
 
+int board_early_init_f(void)
+{
+	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset(wdog);
+
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+
+#ifdef CONFIG_FEC_MXC
+	setup_iomux_fec();
+#endif
+
+	return 0;
+}
+
 int board_init(void)
 {
 	setup_wifi();
-- 
2.21.0

